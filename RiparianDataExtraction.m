function [X,Y,H1,H2,canW1,canW2,BH1,BH2] = RiparianDataExtraction(xo,yo,DEM,FD,DiffMap, ...
    transSpace,shadeThresh,matureHeightCon,matureHeightDec,X_vec,Y_vec,BFW_vec)

% Code to extract tree height and canopy width (horizontal distance
% between trees across channel) used to calculate the canopy opening angle
% in: Seixas, G.B., Beechie, T.J., Fogel, C., and Kiffney, P.M., Influence
% of channel with on stream shade and temperature change in forested
% catchments.

% Copyright Gustav Seixas 2016


% Outputs:
% X, Y >= XY-coordinates of transect center points
% H1, H2 >= tree height on both banks
% canW1, canW2 >= canopy opening width, e.g. the across-channel horizontal
% distance between trees
% BH1, BH2 >= bank height on both banks. This may increase the apparent
% tree height.

% Inputs:
% xo, yo >= XY-coordinates of 'channel head' location, e.g. upper limit of
% stream channel used in the analysis. The algorithm begins at this point
% and proceeds downstream.
% DEM >= Digital elevation model used to calculate bankheight at each
% transect location. Ensure vertical units are same as horizontal units
% FD >= Flow direction grid calculated over a pit-filled version of DEM.
% DiffMap >= Difference surface generated by subtracting DEM from the LiDAR
% first returns raster.
% transSpace >= along-channel distance between transects.
% shadeThresh >= a vector of possible tree height thresholds (see text).
% matureHeightCon >= Conifer mature height used as benchmark for reference
% condition.
% matureHeightDec >= Same as above, but for deciduous trees.
% X_vec, Y_vec >= XY-coordinates of stream reach (channel width) data calculated elsewhere
% BFW_vec >= Bankfull width calcualted and points above (see text).


[Xo,Yo] = SearchDownFlowDirection(FD,xo,yo);

ind = ExtractEvenlySpacedPoints(Xo,Yo,transSpace);

if length(ind) > 1 %test to ensure reach is longer than transect spacing
    X = Xo(ind);
    Y = Yo(ind);
else
    X = NaN;
    Y = NaN;
    H1 = NaN;
    H2 = NaN;
    canW1 = NaN;
    canW2 = NaN;
    BH1 = NaN;
    BH2 = NaN;
    return %this causes the rest of the function to be bypassed if the reach is shorter than the transect spacing
end



%% Transect algorithm
transectLength = 100; %length of transect perpendiculat to channel.
chandist = 100; %distance up and down stream to use to find bisecting angle

for i = 1:length(X)
        
    [ang chandisttemp] = FindChannelPerpendicularAngle(X(i),Y(i),Xo,Yo,chandist);
    
    xdim = abs(floor(transectLength*cos(ang)));
    ydim = abs(floor(transectLength*sin(ang)));
    
    %location within DEM of current channel point:
    [io,jo] = XY2IJ(X(i),Y(i),FD);
    
    
    %pick points off raster starting at channel point and extending 100m in
    %both direction perpendicular to channel using Bresenham Line
    %algorithm
    if Xo(ind(i)+chandisttemp) > Xo(ind(i)-chandisttemp)
        
        if Yo(ind(i)+chandisttemp) > Yo(ind(i)-chandisttemp)
            [i1,j1] = BresenhamLine(size(FD.grid),io,jo,io+ydim,jo-xdim);
            [i2,j2] = BresenhamLine(size(FD.grid),io,jo,io-ydim,jo+xdim);
        else
            [i1,j1] = BresenhamLine(size(FD.grid),io,jo,io+ydim,jo+xdim);
            [i2,j2] = BresenhamLine(size(FD.grid),io,jo,io-ydim,jo-xdim);
        end
        
    else
        if Yo(ind(i)+chandisttemp) > Yo(ind(i)-chandisttemp)
            [i1,j1] = BresenhamLine(size(FD.grid),io,jo,io-ydim,jo-xdim);
            [i2,j2] = BresenhamLine(size(FD.grid),io,jo,io+ydim,jo+xdim);
        else
            [i1,j1] = BresenhamLine(size(FD.grid),io,jo,io-ydim,jo+xdim);
            [i2,j2] = BresenhamLine(size(FD.grid),io,jo,io+ydim,jo-xdim);
        end
    end
    
    
    %% Extract transect from difference map
    
    %Use stream data to calculate closest bankfull width
    dx_w = X(i) - X_vec;
    dy_w = Y(i) - Y_vec;
    dL = sqrt(dx_w.^2 + dy_w.^2);
    
    [~,idx_w] = min(dL);
    BFW(i) = BFW_vec(idx_w);
            
    for r = 1:length(i1)
        diffTrans1(r) = DiffMap.grid(i1(r),j1(r));
        [xpos1(r),ypos1(r)] = IJ2XY(i1(r),j1(r),FD);
    end    
    
    
    %% Canopy opening angle
    for j = 1:length(shadeThresh)
        [thetaCurr(j),thetaHist(j),wid(j),heit(j),bankheight(j)] = CanopyOpeningAngle(DEM,diffTrans1,xpos1,ypos1,X(i),Y(i), ...
            BFW(i),matureHeightCon,matureHeightDec,shadeThresh(j));
    end
    
    [~,idxmin] = min(thetaCurr);
    H1(i) = heit(idxmin);
    canW1(i) = wid(idxmin);
    BH1(i) = bankheight(idxmin);
    
    clear thetaCurr thetaHist wid heit j bankheight xpos1 ypos1 diffTrans1
    
    for r = 1:length(i2)
        diffTrans2(r) = DiffMap.grid(i2(r),j2(r));
        [xpos2(r),ypos2(r)] = ij2xy(i2(r),j2(r),FD);
    end
    
    for j = 1:length(shadeThresh)
        [thetaCurr(j),thetaHist(j),wid(j),heit(j),bankheight(j)] = CanopyOpeningAngle(DEM,diffTrans2,xpos2,ypos2,X(i),Y(i), ...
            BFW(i),matureHeightCon,matureHeightDec,shadeThresh(j));
    end
    
    [~,idxmin] = min(thetaCurr);
    H2(i) = heit(idxmin);
    canW2(i) = wid(idxmin);
    BH2(i) = bankheight(idxmin);
    
    clear thetaCurr thetaHist wid heit buffwid j diffTrans2 xpos2 ypos2 bankheight
    
end


